// @generated by Peggy 5.0.6.
//
// https://peggyjs.org/


class peg$SyntaxError extends SyntaxError {
    constructor(message, expected, found, location) {
        super(message);
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
    }

    format(sources) {
        let str = "Error: " + this.message;
        if (this.location) {
            let src = null;
            const st = sources.find(s => s.source === this.location.source);
            if (st) {
                src = st.text.split(/\r\n|\n|\r/g);
            }
            const s = this.location.start;
            const offset_s = (this.location.source && (typeof this.location.source.offset === "function"))
                ? this.location.source.offset(s)
                : s;
            const loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
            if (src) {
                const e = this.location.end;
                const filler = "".padEnd(offset_s.line.toString().length, " ");
                const line = src[s.line - 1];
                const last = s.line === e.line ? e.column : line.length + 1;
                const hatLen = (last - s.column) || 1;
                str += "\n --> " + loc + "\n"
            + filler + " |\n"
            + offset_s.line + " | " + line + "\n"
            + filler + " | " + "".padEnd(s.column - 1, " ")
            + "".padEnd(hatLen, "^");
            } else {
                str += "\n at " + loc;
            }
        }
        return str;
    }

    static buildMessage(expected, found) {
        function hex(ch) {
            return ch.codePointAt(0).toString(16).toUpperCase();
        }

        const nonPrintable = Object.prototype.hasOwnProperty.call(RegExp.prototype, "unicode")
            ? new RegExp("[\\p{C}\\p{Mn}\\p{Mc}]", "gu")
            : null;
        function unicodeEscape(s) {
            if (nonPrintable) {
                return s.replace(nonPrintable,  ch => "\\u{" + hex(ch) + "}");
            }
            return s;
        }

        function literalEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/"/g,  "\\\"")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g,          ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x"  + hex(ch)));
        }

        function classEscape(s) {
            return unicodeEscape(s
                .replace(/\\/g, "\\\\")
                .replace(/\]/g, "\\]")
                .replace(/\^/g, "\\^")
                .replace(/-/g,  "\\-")
                .replace(/\0/g, "\\0")
                .replace(/\t/g, "\\t")
                .replace(/\n/g, "\\n")
                .replace(/\r/g, "\\r")
                .replace(/[\x00-\x0F]/g,          ch => "\\x0" + hex(ch))
                .replace(/[\x10-\x1F\x7F-\x9F]/g, ch => "\\x"  + hex(ch)));
        }

        const DESCRIBE_EXPECTATION_FNS = {
            literal(expectation) {
                return "\"" + literalEscape(expectation.text) + "\"";
            },

            class(expectation) {
                const escapedParts = expectation.parts.map(
                    part => (Array.isArray(part)
                        ? classEscape(part[0]) + "-" + classEscape(part[1])
                        : classEscape(part))
                );

                return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]" + (expectation.unicode ? "u" : "");
            },

            any() {
                return "any character";
            },

            end() {
                return "end of input";
            },

            other(expectation) {
                return expectation.description;
            },
        };

        function describeExpectation(expectation) {
            return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }

        function describeExpected(expected) {
            const descriptions = expected.map(describeExpectation);
            descriptions.sort();

            if (descriptions.length > 0) {
                let j = 1;
                for (let i = 1; i < descriptions.length; i++) {
                    if (descriptions[i - 1] !== descriptions[i]) {
                        descriptions[j] = descriptions[i];
                        j++;
                    }
                }
                descriptions.length = j;
            }

            switch (descriptions.length) {
            case 1:
                return descriptions[0];

            case 2:
                return descriptions[0] + " or " + descriptions[1];

            default:
                return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
            }
        }

        function describeFound(found) {
            return found ? "\"" + literalEscape(found) + "\"" : "end of input";
        }

        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
    }
}

function peg$parse(input, options) {
    options = options !== undefined ? options : {};

    const peg$FAILED = {};
    const peg$source = options.grammarSource;

    const peg$startRuleFunctions = {
        array: peg$parsearray,
    };
    let peg$startRuleFunction = peg$parsearray;

    const peg$c0 = "[";
    const peg$c1 = "]";

    const peg$r0 = /^[[\]]/;

    const peg$e0 = peg$literalExpectation("[", false);
    const peg$e1 = peg$literalExpectation("]", false);
    const peg$e2 = peg$classExpectation(["[", "]"], false, false, false);
    const peg$e3 = peg$anyExpectation();

    function peg$f0(value) {    return () => value;  }
    function peg$f1(value) {    return value;  }
    function peg$f2(value) {
        for (const item of value) {
    	if (typeof item === 'function') {
        	value.splice(value.indexOf(item), 1, ...item());
            }
        }
    
        return value;
    }
    function peg$f3(value) {    return value.flat(1).filter(Boolean);  }
    let peg$currPos = options.peg$currPos | 0;
    let peg$savedPos = peg$currPos;
    const peg$posDetailsCache = [{ line: 1, column: 1 }];
    let peg$maxFailPos = peg$currPos;
    let peg$maxFailExpected = options.peg$maxFailExpected || [];
    let peg$silentFails = options.peg$silentFails | 0;

    let peg$result;

    if (options.startRule) {
        if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
        }

        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function peg$getUnicode(pos = peg$currPos) {
        const cp = input.codePointAt(pos);
        if (cp === undefined) {
            return "";
        }
        return String.fromCodePoint(cp);
    }

    function peg$literalExpectation(text, ignoreCase) {
        return { type: "literal", text, ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase, unicode) {
        return { type: "class", parts, inverted, ignoreCase, unicode };
    }

    function peg$anyExpectation() {
        return { type: "any" };
    }

    function peg$endExpectation() {
        return { type: "end" };
    }

    function peg$computePosDetails(pos) {
        let details = peg$posDetailsCache[pos];
        let p;

        if (details) {
            return details;
        } else {
            if (pos >= peg$posDetailsCache.length) {
                p = peg$posDetailsCache.length - 1;
            } else {
                p = pos;
                while (!peg$posDetailsCache[--p]) {}
            }

            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column,
            };

            while (p < pos) {
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else {
                    details.column++;
                }

                p++;
            }

            peg$posDetailsCache[pos] = details;

            return details;
        }
    }

    function peg$computeLocation(startPos, endPos, offset) {
        const startPosDetails = peg$computePosDetails(startPos);
        const endPosDetails = peg$computePosDetails(endPos);

        const res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column,
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column,
            },
        };
        if (offset && peg$source && (typeof peg$source.offset === "function")) {
            res.start = peg$source.offset(res.start);
            res.end = peg$source.offset(res.end);
        }
        return res;
    }

    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) { return; }

        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }

        peg$maxFailExpected.push(expected);
    }

    function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(
            peg$SyntaxError.buildMessage(expected, found),
            expected,
            found,
            location
        );
    }

    function peg$parsearray() {
        let s0, s1, s2, s3, s4, s5;

        s0 = peg$currPos;
        s1 = [];
        s2 = peg$currPos;
        s3 = peg$parsestring();
        if (s3 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$f0(s3);
        }
        s2 = s3;
        if (s2 === peg$FAILED) {
            s2 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
                s3 = peg$c0;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e0); }
            }
            if (s3 !== peg$FAILED) {
                s4 = peg$parsearray();
                if (input.charCodeAt(peg$currPos) === 93) {
                    s5 = peg$c1;
                    peg$currPos++;
                } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e1); }
                }
                if (s5 !== peg$FAILED) {
                    peg$savedPos = s2;
                    s2 = peg$f1(s4);
                } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
            }
        }
        while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$currPos;
            s3 = peg$parsestring();
            if (s3 !== peg$FAILED) {
                peg$savedPos = s2;
                s3 = peg$f0(s3);
            }
            s2 = s3;
            if (s2 === peg$FAILED) {
                s2 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 91) {
                    s3 = peg$c0;
                    peg$currPos++;
                } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$e0); }
                }
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsearray();
                    if (input.charCodeAt(peg$currPos) === 93) {
                        s5 = peg$c1;
                        peg$currPos++;
                    } else {
                        s5 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$e1); }
                    }
                    if (s5 !== peg$FAILED) {
                        peg$savedPos = s2;
                        s2 = peg$f1(s4);
                    } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                }
            }
        }
        peg$savedPos = s0;
        s1 = peg$f2(s1);
        s0 = s1;

        return s0;
    }

    function peg$parsestring() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsechar();
        if (s2 !== peg$FAILED) {
            while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsechar();
            }
        } else {
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f3(s1);
        }
        s0 = s1;

        return s0;
    }

    function peg$parsechar() {
        let s0, s1, s2;

        s0 = peg$currPos;
        s1 = peg$currPos;
        peg$silentFails++;
        s2 = input.charAt(peg$currPos);
        if (peg$r0.test(s2)) {
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$e2); }
        }
        peg$silentFails--;
        if (s2 === peg$FAILED) {
            s1 = undefined;
        } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
            } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$e3); }
            }
            if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }

        return s0;
    }

    peg$result = peg$startRuleFunction();

    const peg$success = (peg$result !== peg$FAILED && peg$currPos === input.length);
    function peg$throw() {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
        }

        throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? peg$getUnicode(peg$maxFailPos) : null,
            peg$maxFailPos < input.length
                ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
        );
    }
    if (options.peg$library) {
        return /** @type {any} */ ({
            peg$result,
            peg$currPos,
            peg$FAILED,
            peg$maxFailExpected,
            peg$maxFailPos,
            peg$success,
            peg$throw: peg$success ? undefined : peg$throw,
        });
    }
    if (peg$success) {
        return peg$result;
    } else {
        peg$throw();
    }
}

const peg$allowedStartRules = [
    "array"
];

export {
    peg$parse as parse, peg$allowedStartRules as StartRules,
    peg$SyntaxError as SyntaxError
};

